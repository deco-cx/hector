# Hector AI App Builder Data Schemas

This document outlines the data schemas used in the Hector AI App Builder platform, separating the app configuration schema from the runtime schema.

## 1. App Configuration Schema

The app configuration schema defines how an app is structured and stored in the system. Each app is represented as a JSON object with the following structure:

```json
{
  "id": "string",
  "name": "string",
  "template": "string",
  "style": "string",
  "inputs": [InputField],
  "actions": [Action],
  "output": OutputConfiguration
}
```

### 1.1 InputField Schema

Input fields define what data the app will collect from users:

```json
{
  "filename": "string",
  "type": "text | image | select | file | audio",
  "title": {
    "EN": "string",
    "PT": "string"
  },
  "required": boolean,
  "multiValue": boolean,
  "cleanOnStartup": boolean,
  "options": [string],  // Only for "select" type
  "defaultValue": any   // Optional default value
}
```

- **filename**: Acts as a variable identifier (e.g., "child_name.md")
- **type**: Determines the input widget type
- **title**: Multilingual labels for the input field
- **required**: Whether the input is mandatory
- **multiValue**: Whether multiple values can be provided
- **cleanOnStartup**: Whether to clear the value when the app starts
- **options**: For "select" type, the available options
- **defaultValue**: Optional default value for the field

### 1.2 Action Schema

Actions define the AI operations to be performed:

```json
{
  "type": "Gerar JSON | Gerar Texto | Gerar Imagem | Gerar AÃºdio",
  "prompt": {
    "EN": "string",
    "PT": "string"
  },
  "output_filename": "string",
  "model": "string",
  "parameters": {
    // Model-specific parameters
  }
}
```

- **type**: The type of AI generation to perform
- **prompt**: Multilingual prompts that can reference input variables using @filename syntax
- **output_filename**: Where the generated content will be stored (becomes a variable)
- **model**: Optional AI model to use
- **parameters**: Model-specific parameters (e.g., temperature, max tokens)

### 1.3 OutputConfiguration Schema

Defines how the app's results are presented:

```json
{
  "type": "html | json | files",
  "template": "string",
  "files": [string]
}
```

- **type**: The format of the output
- **template**: For HTML outputs, a template to structure the content
- **files**: References to generated files using @filename syntax

## 2. Runtime Schema

The runtime schema defines how data flows during app execution.

### 2.1 RuntimeState

```json
{
  "appConfig": AppConfiguration,
  "inputValues": {
    "filename1": value1,
    "filename2": value2,
    // ...
  },
  "generatedOutputs": {
    "output_filename1": content1,
    "output_filename2": content2,
    // ...
  },
  "currentLanguage": "EN | PT",
  "status": "idle | generating | complete | error",
  "error": "string"
}
```

- **appConfig**: The configuration of the running app
- **inputValues**: Values provided by the user for each input field
- **generatedOutputs**: Content generated by actions
- **currentLanguage**: The active language for UI and content
- **status**: The current state of the app
- **error**: Error message if status is "error"

### 2.2 File Reference System

In Hector, "files" function primarily as variables within the system, but are also persisted in the Webdraw filesystem:

1. **Input Files**: When a user defines an input with filename "child_name.md", this creates a variable that can be referenced in actions using @child_name.md syntax.

2. **Generated Files**: When an action produces output with filename "story.md", this creates a variable that can be referenced in subsequent actions or in the output configuration using @story.md syntax.

3. **Variable Resolution**: During runtime, references like @child_name.md are resolved to their actual values from the inputValues or generatedOutputs objects.

4. **Persistence**: The runtime will save values in the filesystem so no state is lost, using the `~/Hector/executions` path for debugging and persistence purposes.

### 2.3 Action Execution Flow

1. User provides values for input fields
2. System creates inputValues object mapping filenames to values
3. Actions execute in sequence:
   - Action prompts are processed, replacing @filename references with actual values
   - Generated content is stored in generatedOutputs with the specified output_filename
   - Subsequent actions can reference both input values and previously generated outputs
   - If an action references a file that doesn't exist yet, it will fail, so the app must ensure necessary files are initiated in the correct order
4. Output is assembled using the specified template and files

## 3. Storage Implementation

### 3.1 App Configuration Storage

App configurations are stored as JSON files in the `~/Hector/apps/` directory using the Webdraw filesystem. The platform uses the following Webdraw SDK methods for basic CRUD operations:

- `fs.list`: To retrieve all available apps
- `fs.readFile`: To load an app's configuration
- `fs.write`: To save or update an app's configuration

Since Webdraw FS already provides a different drive for each user, the app doesn't need to worry about multitenancy.

### 3.2 Runtime Data Storage

- **Input Values**: User inputs are persisted in the Webdraw filesystem under `~/Hector/executions/` for debugging purposes and to maintain state between sessions.

- **Generated Outputs**: 
  - For AI-generated assets (images, audio), the Webdraw AI methods return a URL for the generated asset.
  - These URLs can be made publicly accessible by prefixing them with `fs.webdraw.com`.
  - Example for image generation:
    ```javascript
    // The SDK handles the storage of the generated image
    const imageResult = await sdk.ai.generateImage({
      model: "openai:dall-e-3",
      prompt: imagePrompt
    });
    
    // The result contains a URL or filepath that can be made public
    let imageUrl = imageResult.url || imageResult.filepath;
    if (imageUrl && !imageUrl.startsWith('http')) {
      imageUrl = `https://fs.webdraw.com${imageUrl.startsWith('/') ? '' : '/'}${imageUrl}`;
    }
    ```

- **Caching**: If an action was previously executed, its value remains available for debugging purposes (when editing), but will be replaced if the action is executed again.

### 3.3 File Permissions

All files in the Webdraw filesystem are currently public for read access by default. This applies to both app configurations and generated content.

### 3.4 Language Preferences

For multilingual content (like input titles in EN and PT):
- The system uses the browser's default language initially
- Language preferences are saved in localStorage
- Users can manually change their language preference through the UI

## 4. Example Data Flow

### Configuration:
```json
{
  "inputs": [
    {
      "filename": "character_name.md",
      "type": "text",
      "title": {"EN": "Character Name"}
    }
  ],
  "actions": [
    {
      "type": "Gerar Texto",
      "prompt": {"EN": "Write a story about @character_name.md"},
      "output_filename": "story.md"
    },
    {
      "type": "Gerar Imagem",
      "prompt": {"EN": "Create an illustration for a story about @character_name.md"},
      "output_filename": "illustration.png"
    }
  ],
  "output": {
    "type": "html",
    "files": ["@story.md", "@illustration.png"]
  }
}
```

### Runtime:
1. User enters "Alice" for character_name.md
2. System creates inputValues: {"character_name.md": "Alice"}
3. First action executes with prompt "Write a story about Alice"
4. Generated story is stored in generatedOutputs: {"story.md": "Once upon a time..."}
5. Second action executes with prompt "Create an illustration for a story about Alice"
6. Generated image is stored in generatedOutputs: {"illustration.png": [URL to image]}
7. Output is assembled using story.md and illustration.png content
8. All input values and generated outputs are persisted in `~/Hector/executions/` for debugging and future reference

## 5. Export Implementation

When exporting an app, the system will use AI to handle the packaging of the app configuration. The export functionality is designed to be implemented in a future version, with a placeholder function that will call AI for this purpose.
